# Zoeyr Project Cursor Rules

## Serialization Standards

### CRITICAL: Always use postcard for serialization

**NEVER use `serde_json` for data serialization in this project.**

- ✅ **DO**: Use `postcard` for all binary data serialization/deserialization
- ✅ **DO**: Use `postcard::to_stdvec()` and `postcard::from_bytes()` for standard operations
- ✅ **DO**: Use `postcard::to_allocvec()` when you need Vec<u8> allocation
- ❌ **DON'T**: Use `serde_json::to_string()`, `serde_json::from_str()`, or any serde_json methods
- ❌ **DON'T**: Add `serde_json` as a dependency to new crates

### When postcard is appropriate (99% of cases)
- Message serialization in wire protocol
- State machine event serialization
- Network communication data
- Blob storage data
- Any binary data that needs to be stored or transmitted
- Inter-service communication
- Encrypted data payloads

### Limited exceptions for serde_json (rare cases only)
- **ONLY** for human-readable configuration files that users need to edit manually
- **ONLY** for debugging/logging output where human readability is critical
- **ONLY** for interoperability with external JSON APIs (like WhatsApp integration)

### Code Examples

**✅ CORRECT - Use postcard:**
```rust
use postcard;

// Serialization
let data = MyStruct { field: "value" };
let bytes = postcard::to_stdvec(&data)?;

// Deserialization  
let recovered: MyStruct = postcard::from_bytes(&bytes)?;

// For Vec<u8> allocation
let bytes = postcard::to_allocvec(&data)?;
```

**❌ INCORRECT - Don't use serde_json:**
```rust
// DON'T DO THIS
let json = serde_json::to_string(&data)?;
let recovered: MyStruct = serde_json::from_str(&json)?;
```

## Dependencies

### Required workspace dependencies
- Use `postcard = { workspace = true }` in Cargo.toml
- Import with `use postcard;` 
- Handle errors with `postcard::Error`

### Error handling
- postcard errors should be wrapped in your crate's error type
- Use `#[from] postcard::Error` in error enums where appropriate

## Architecture Consistency

### Wire Protocol
- This project uses postcard for efficient binary serialization across the wire
- The `PostcardFormat` struct in `wire-protocol/src/relay/postcard.rs` is the standard serialization format
- All RPC communication uses postcard via tarpc's serde-transport

### State Management
- Group state and events are serialized with postcard
- Message content uses postcard serialization
- Encrypted payloads contain postcard-serialized data

### Performance
- Postcard provides compact binary serialization, crucial for network efficiency
- JSON serialization would significantly increase bandwidth usage
- Binary formats are more efficient for cryptographic operations

## Migration Guidelines

If you encounter existing serde_json usage:
1. Evaluate if it's truly necessary for human readability
2. If not, replace with postcard equivalents:
   - `serde_json::to_string()` → `postcard::to_stdvec()`
   - `serde_json::from_str()` → `postcard::from_bytes()`
   - `serde_json::to_vec()` → `postcard::to_stdvec()`
3. Update error handling to work with `postcard::Error`
4. Ensure structs have `Serialize, Deserialize` derives (same as before)

## Testing & Quality Assurance

### CRITICAL: Always verify your changes before completion

**Before telling the user you're done, you MUST:**

1. **Run the complete test suite:**
   ```bash
   cargo nextest run --all
   ```
   - Fix any failing tests before proceeding
   - All tests must pass before completion

2. **Run clippy and fix all issues:**
   ```bash
   cargo +nightly clippy --all --tests --examples --allow-dirty --allow-staged --fix
   ```
   - Fix any clippy warnings/errors that remain after auto-fix
   - Ensure clean compilation across all targets

3. **Verify compilation:**
   - Ensure all crates, tests, and examples compile successfully
   - Check that no compilation errors remain

### Testing Guidelines
- Always test serialization/deserialization round trips with postcard
- Use `postcard::to_stdvec()` and `postcard::from_bytes()` in tests
- Binary compatibility tests should use postcard format
- Run `cargo nextest run --all` to execute the full test suite
- Never skip test verification when making code changes

### Code Quality
- Use `cargo clippy` to catch common mistakes and improve code quality
- Fix all clippy warnings before completion
- Ensure consistent coding style across the project

### Test Coverage
- **Write unit tests** for new functions, methods, and modules whenever feasible
- **Write integration tests** for new features and user-facing functionality
- **Test error paths** and edge cases, not just happy paths
- **Use descriptive test names** that explain what is being tested
- **Group related tests** using `mod tests` blocks or separate test files
- **Mock external dependencies** when writing unit tests
- **Test serialization round trips** when adding new serializable types

## Documentation Guidelines

### What NOT to create (unless explicitly requested)
- ❌ **DON'T** proactively create long markdown files or README files
- ❌ **DON'T** create extensive documentation files without explicit user request
- ❌ **DON'T** generate verbose documentation that won't be maintained

### What TO create and maintain
- ✅ **DO** write clear inline code documentation (`///` doc comments)
- ✅ **DO** document public APIs, function parameters, and return values
- ✅ **DO** keep inline documentation up-to-date with code changes
- ✅ **DO** create CLI usage documentation for new command-line examples
- ✅ **DO** update existing READMEs and docs when making user-facing changes

### Documentation Quality
- **Be concise but clear** in inline documentation
- **Document the "why" not just the "what"** for complex logic
- **Include examples** in doc comments for non-trivial functions
- **Update related documentation** when changing user-facing functionality
- **Check existing docs** for accuracy when modifying public interfaces

### End-of-Task Documentation Check
When creating user-facing code, always verify:
1. Are there existing READMEs that need updates?
2. Do CLI examples need usage documentation?
3. Are public API changes documented?
4. Is inline documentation accurate and up-to-date?

---

**WORKFLOW SUMMARY:**
1. Make your code changes using postcard (never serde_json)
2. Write unit/integration tests for new functionality
3. Add clear inline documentation for public APIs
4. Run `cargo nextest run --all` and fix any test failures
5. Run `cargo +nightly clippy --all --tests --examples --allow-dirty --allow-staged --fix`
6. Fix any remaining clippy issues
7. Check if existing docs need updates for user-facing changes
8. Only then tell the user you're complete

**Remember: This project prioritizes efficiency and binary compatibility. Always default to postcard unless you have a compelling reason for human-readable JSON format.**