# Zoeyr Project Cursor Rules

## Communication Guidelines

### Professional Tone
- Be direct, helpful, and professional in responses
- Focus on technical accuracy and clarity
- Avoid excessive compliments or unnecessary praise
- Get straight to the point with actionable information
- Acknowledge requests simply and move to implementation
- Be critical and point out when proposed ideas conflict with existing code

## Type Safety Standards

### CRITICAL: Prefer type-safe protocols over string-based typing

**Always prioritize type safety in protocol design and implementation:**

- ✅ **DO**: Use strongly-typed enums, structs, and type definitions
- ✅ **DO**: Leverage Rust's type system to catch errors at compile time
- ✅ **DO**: Define clear type boundaries in wire protocols and APIs
- ✅ **DO**: Use `#[repr(u8)]` or similar for network-serializable enums
- ❌ **DON'T**: Use string-based type discrimination when type-safe alternatives exist
- ❌ **DON'T**: Rely on runtime string parsing for type identification
- ❌ **DON'T**: Use magic strings or string constants for type matching

### Type Safety Examples

**✅ CORRECT - Type-safe approach:**
```rust
#[derive(Serialize, Deserialize)]
#[repr(u8)]
enum MessageType {
    Text = 0,
    Image = 1,
    File = 2,
}

#[derive(Serialize, Deserialize)]
struct Message {
    msg_type: MessageType,
    content: MessageContent,
}
```

**❌ INCORRECT - String-based typing:**
```rust
#[derive(Serialize, Deserialize)]
struct Message {
    msg_type: String, // "text", "image", "file"
    content: String,
}
```

### Protocol Design
- Wire protocols should use type-safe enumerations
- API boundaries should enforce type constraints at compile time
- Message formats should leverage discriminated unions over string tags
- Error types should be strongly typed rather than generic string messages

## Data Structure Standards

### CRITICAL: Prefer BTreeMaps over HashMaps

**Always prioritize BTreeMaps for data structures, especially serializable types:**

- ✅ **DO**: Use `BTreeMap` for key-value mappings in serializable structures
- ✅ **DO**: Use `BTreeSet` for sets in serializable structures  
- ✅ **DO**: Use `BTreeMap` for deterministic ordering and consistent serialization
- ✅ **DO**: Use `BTreeMap` for better binary serialization compatibility
- ❌ **DON'T**: Use `HashMap` unless you have a specific performance requirement
- ❌ **DON'T**: Use `HashSet` for serializable data structures
- ❌ **DON'T**: Mix HashMap and BTreeMap inconsistently across the codebase

### Data Structure Examples

**✅ CORRECT - BTreeMap usage:**
```rust
use std::collections::BTreeMap;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct UserData {
    preferences: BTreeMap<String, String>,
    groups: BTreeMap<u64, GroupInfo>,
}
```

**❌ INCORRECT - HashMap usage:**
```rust
use std::collections::HashMap;

#[derive(Serialize, Deserialize)]
struct UserData {
    preferences: HashMap<String, String>, // Non-deterministic ordering
    groups: HashMap<u64, GroupInfo>, // Inconsistent serialization
}
```

### When BTreeMap is preferred (99% of cases)
- All serializable data structures
- Configuration data
- State machine data  
- Wire protocol messages
- Database models
- Any data that needs consistent ordering
- General key-value storage needs

### Limited exceptions for HashMap (rare cases only)
- **ONLY** when you have measured performance bottlenecks with BTreeMap
- **ONLY** for internal, non-serializable caches where ordering doesn't matter
- **ONLY** when interfacing with external APIs that specifically require HashMap

## Import Standards

### CRITICAL: Prefer imports over full-path-type-definitions

**Always prioritize clean imports at the top of files:**

- ✅ **DO**: Use top-level imports for all types and functions
- ✅ **DO**: Use alias renaming (`use foo::Bar as FooBar`) to resolve conflicts
- ✅ **DO**: Group and organize imports logically
- ❌ **DON'T**: Use full-path type definitions (`foo::bar::Baz`) in function bodies
- ❌ **DON'T**: Inline full paths except for single-use conflict resolution

### Import Examples

**✅ CORRECT - Top-level imports:**
```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use crate::message::Message;
use crate::crypto::EncryptedData;
use external_crate::Config as ExternalConfig;

fn process_data(data: HashMap<String, Message>) -> EncryptedData {
    // Use imported types directly
}
```

**❌ INCORRECT - Full-path usage:**
```rust
fn process_data(data: std::collections::HashMap<String, crate::message::Message>) -> crate::crypto::EncryptedData {
    // Avoid this pattern
}
```

### When full paths are acceptable
- **ONLY** when there's a name conflict and the type is used exactly once in the file
- **ONLY** for disambiguation in macro contexts where imports don't work

## Serialization Standards

### CRITICAL: Always use postcard for serialization

**NEVER use `serde_json` for data serialization in this project.**

- ✅ **DO**: Use `postcard` for all binary data serialization/deserialization
- ✅ **DO**: Use `postcard::to_stdvec()` and `postcard::from_bytes()` for standard operations
- ✅ **DO**: Use `postcard::to_allocvec()` when you need Vec<u8> allocation
- ❌ **DON'T**: Use `serde_json::to_string()`, `serde_json::from_str()`, or any serde_json methods
- ❌ **DON'T**: Add `serde_json` as a dependency to new crates

### When postcard is appropriate (99% of cases)
- Message serialization in wire protocol
- State machine event serialization
- Network communication data
- Blob storage data
- Any binary data that needs to be stored or transmitted
- Inter-service communication
- Encrypted data payloads

### Limited exceptions for serde_json (rare cases only)
- **ONLY** for human-readable configuration files that users need to edit manually
- **ONLY** for debugging/logging output where human readability is critical
- **ONLY** for interoperability with external JSON APIs (like WhatsApp integration)

### Code Examples

**✅ CORRECT - Use postcard:**
```rust
use postcard;

// Serialization
let data = MyStruct { field: "value" };
let bytes = postcard::to_stdvec(&data)?;

// Deserialization  
let recovered: MyStruct = postcard::from_bytes(&bytes)?;

// For Vec<u8> allocation
let bytes = postcard::to_allocvec(&data)?;
```

**❌ INCORRECT - Don't use serde_json:**
```rust
// DON'T DO THIS
let json = serde_json::to_string(&data)?;
let recovered: MyStruct = serde_json::from_str(&json)?;
```

## Dependencies

### Required workspace dependencies
- Use `postcard = { workspace = true }` in Cargo.toml
- Import with `use postcard;` 
- Handle errors with `postcard::Error`

### Error handling
- postcard errors should be wrapped in your crate's error type
- Use `#[from] postcard::Error` in error enums where appropriate

## Architecture Consistency

### Wire Protocol
- This project uses postcard for efficient binary serialization across the wire
- The `PostcardFormat` struct in `wire-protocol/src/relay/postcard.rs` is the standard serialization format
- All RPC communication uses postcard via tarpc's serde-transport

### State Management
- Group state and events are serialized with postcard
- Message content uses postcard serialization
- Encrypted payloads contain postcard-serialized data

### Performance
- Postcard provides compact binary serialization, crucial for network efficiency
- JSON serialization would significantly increase bandwidth usage
- Binary formats are more efficient for cryptographic operations

## Migration Guidelines

If you encounter existing serde_json usage:
1. Evaluate if it's truly necessary for human readability
2. If not, replace with postcard equivalents:
   - `serde_json::to_string()` → `postcard::to_stdvec()`
   - `serde_json::from_str()` → `postcard::from_bytes()`
   - `serde_json::to_vec()` → `postcard::to_stdvec()`
3. Update error handling to work with `postcard::Error`
4. Ensure structs have `Serialize, Deserialize` derives (same as before)

## Testing & Quality Assurance

### CRITICAL: Always verify your changes before completion

**Before telling the user you're done, you MUST:**

1. **Run the complete test suite:**
   ```bash
   cargo nextest run --all
   ```
   - Fix any failing tests before proceeding
   - All tests must pass before completion

2. **Run clippy and fix all issues:**
   ```bash
   cargo +nightly clippy --all --tests --examples --allow-dirty --allow-staged --fix
   ```
   - Fix any clippy warnings/errors that remain after auto-fix
   - Ensure clean compilation across all targets

3. **Verify compilation:**
   - Ensure all crates, tests, and examples compile successfully
   - Check that no compilation errors remain

### Testing Guidelines
- Always test serialization/deserialization round trips with postcard
- Use `postcard::to_stdvec()` and `postcard::from_bytes()` in tests
- Binary compatibility tests should use postcard format
- Run `cargo nextest run --all` to execute the full test suite
- Never skip test verification when making code changes

### Code Quality
- Use `cargo clippy` to catch common mistakes and improve code quality
- Fix all clippy warnings before completion
- Ensure consistent coding style across the project

### Test Coverage
- **Write unit tests** for new functions, methods, and modules whenever feasible
- **Write integration tests** for new features and user-facing functionality
- **Test error paths** and edge cases, not just happy paths
- **Use descriptive test names** that explain what is being tested
- **Group related tests** using `mod tests` blocks or separate test files
- **Mock external dependencies** when writing unit tests
- **Test serialization round trips** when adding new serializable types

## Documentation Guidelines

### What NOT to create (unless explicitly requested)
- ❌ **DON'T** proactively create long markdown files or README files
- ❌ **DON'T** create extensive documentation files without explicit user request
- ❌ **DON'T** generate verbose documentation that won't be maintained

### What TO create and maintain
- ✅ **DO** write clear inline code documentation (`///` doc comments)
- ✅ **DO** document public APIs, function parameters, and return values
- ✅ **DO** keep inline documentation up-to-date with code changes
- ✅ **DO** create CLI usage documentation for new command-line examples
- ✅ **DO** update existing READMEs and docs when making user-facing changes

### Documentation Quality
- **Be concise but clear** in inline documentation
- **Document the "why" not just the "what"** for complex logic
- **Include examples** in doc comments for non-trivial functions
- **Update related documentation** when changing user-facing functionality
- **Check existing docs** for accuracy when modifying public interfaces

### End-of-Task Documentation Check
When creating user-facing code, always verify:
1. Are there existing READMEs that need updates?
2. Do CLI examples need usage documentation?
3. Are public API changes documented?
4. Is inline documentation accurate and up-to-date?

---

**WORKFLOW SUMMARY:**
1. Make your code changes using postcard (never serde_json)
2. Write unit/integration tests for new functionality
3. Add clear inline documentation for public APIs
4. Run `cargo nextest run --all` and fix any test failures
5. Run `cargo +nightly clippy --all --tests --examples --allow-dirty --allow-staged --fix`
6. Fix any remaining clippy issues
7. Check if existing docs need updates for user-facing changes
8. Only then tell the user you're complete

**Remember: This project prioritizes efficiency and binary compatibility. Always default to postcard unless you have a compelling reason for human-readable JSON format.**